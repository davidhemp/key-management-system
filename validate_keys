#!/bin/bash
# Takes the inputs from the AuthorizedKeysCommand command and returns the public key if it is allowed and 1 if it is not. 
# This runs as the user to ensure access to home directory for root squashed filesystems.
# In sshd_config add the following without the comments:
# PubkeyAuthentication yes
# AuthorizedKeysFile /dev/null
# AuthorizedKeysCommand /usr/bin/validate_keys %u %h %k %f %t
# AuthorizedKeysCommandUser %u

username=$1
user_home_dir=$2
key_to_test=$3
fingerprint=$4
key_type=$5

key_file=${user_home_dir}/.ssh/authorized_keys

logging=1
function log {
	if [[ ${logging} -eq 1 ]]; then
		logger -p authpriv.debug ${1}
	fi
}
log "User attempting to login in with key:${fingerprint}"; 

if grep -q "${key_type} ${key_to_test}" ${key_file} ; then
	log "Key ${fingerprint} found in ${key_file}" 
	cutoff=$(./mysql-connect "SELECT unix_timestamp(cutoff_date) FROM public_keys WHERE fingerprint = '${fingerprint}'")
	if [ -z ${cutoff} ] ; then
		log "key not in db yet. Adding it with todays date."
		#Keys are not valid after a year
		sql="INSERT INTO public_keys (username, fingerprint, cutoff_date) VALUES ('${username}', '${fingerprint}', date_add(now(),interval 365 day))"
		./mysql-connect "${sql}"
		echo "${key_type} ${key_to_test}"
		exit 
	else
		log "cutoff_date is ${cutoff}"
		now=$(date "+%s")
		if [[ "${now}" -gt "${cutoff}" ]] ; then
			log "Cutoff date has passed for key: ${fingerprint}"
			exit 
		else
			log "User ${username} can connect with: ${fingerprint}"
			echo "${key_type} ${key_to_test}"
			exit 
		fi
	fi
else
	log "Key ${fingerprint} NOT in ${key_file}"
	exit 
fi
